const test = require('ava');
const shortid = require('shortid');
const { validateSnapshotRepository } = require('hebo/validators');
const SnapshotRepositoryS3 = require('..');
const makeS3Client = require('./helpers/s3-client');

const makeRepo = () =>
    new SnapshotRepositoryS3({
        s3Client: makeS3Client(),
        s3Path: 's3://snapshots-r-us/testing/',
    });

test('passes validator', t => {
    const repo = makeRepo();
    const { error } = validateSnapshotRepository(repo);
    t.is(error, null, 'no error generated by validation');
});

test('writeSnapshot(), getSnapshot()', async t => {
    const repo = makeRepo();
    const bookId = shortid.generate();

    t.deepEqual(
        await repo.getSnapshot('book', bookId),
        undefined,
        'getSnapshot returns undefined if no snapshot exists',
    );

    const snapshot = {
        version: 4,
        state: {
            bookName: 'Ulysses',
            author: 'Joyce',
            yearPublished: 1922,
        },
    };

    t.true(
        await repo.writeSnapshot('book', bookId, snapshot),
        'writeSnapshot returns true after writing snapshot',
    );

    t.deepEqual(
        await repo.getSnapshot('book', bookId),
        snapshot,
        'getSnapshot() finds snapshot stored by writeSnapshot()',
    );

    t.deepEqual(
        await repo.getSnapshot('book', shortid.generate()),
        undefined,
        'getSnapshot() respects aggregate ID',
    );

    t.deepEqual(
        await repo.getSnapshot('author', bookId),
        undefined,
        'getSnapshot() respects aggregate name',
    );
});
